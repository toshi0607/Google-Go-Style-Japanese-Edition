- [Goスタイルガイド](#goスタイルガイド)
  - [スタイルの原則](#スタイルの原則)
    - [明確さ](#明確さ)
      - [コードが実際に行っていることは何か？](#コードが実際に行っていることは何か)
      - [なぜそのようなコードになっているのか？](#なぜそのようなコードになっているのか)
    - [シンプルさ](#シンプルさ)
      - [最小限のメカニズム](#最小限のメカニズム)
    - [簡潔さ](#簡潔さ)
    - [保守性](#保守性)
    - [一貫性](#一貫性)

# Goスタイルガイド

https://google.github.io/styleguide/go/guide

注意: このドキュメントは、Googleでの[Goスタイル](https://google.github.io/styleguide/go/index)の概要を説明する一連のドキュメントの一部です。このドキュメントは規範的かつ標準的なものです。詳しくは、[概要](https://github.com/toshi0607/Google-Go-Style-Japanese-Edition#%E6%A6%82%E8%A6%81)をご覧ください。

## スタイルの原則

読みやすいGoコードの書き方には、いくつかの包括的な原則があります。以下は、読みやすいコードの属性で、重要なものから順に並べています。

- [明確さ](#明確さ): コードの目的と根拠が読み手にとって明確であること
- [シンプルさ](#シンプルさ): コードができるだけシンプルな方法で目的を達成していること
- [簡潔さ](#簡潔さ): 信号対雑音比が高いこと
- [保守性](#保守性): 保守しやすいコードであること
- 一貫性: Googleのコードベースと整合性がとれている

### 明確さ

可読性の中核となる目標は、読み手にとって明確なコードを作成することです。

このことは、効果的な命名、役に立つコメント、効率的なコード構成によって達成されます。

このとき、コードの記述者ではなく、読み手の視点に立つことが大切です。コードが読みやすいことは、書きやすいことよりも重要です。コードの明確さには、2つの異なる側面があります。

- [Goスタイルガイド](#goスタイルガイド)
  - [スタイルの原則](#スタイルの原則)
    - [明確さ](#明確さ)
      - [コードが実際に行っていることは何か？](#コードが実際に行っていることは何か)
      - [なぜそのようなコードになっているのか？](#なぜそのようなコードになっているのか)
    - [シンプルさ](#シンプルさ)
      - [最小限のメカニズム](#最小限のメカニズム)
    - [簡潔さ](#簡潔さ)
    - [保守性](#保守性)
    - [一貫性](#一貫性)

#### コードが実際に行っていることは何か？

Goは、コードが何をしているのかが比較的わかりやすいように設計されています。しかし、コードを理解するために読者が予備知識を必要とするような不確実な場合は、将来の読者のためにコードの目的を明確にするために時間を費やす価値があります。たとえば、以下のようなことが考えられます。

- より説明的な変数名を使用する
-コメントを追加する
- 空白文字やコメントでコードを分割する
- コードを別の関数やメソッドにリファクタリングして、よりモジュール化する

万能のアプローチはありませんが、Goのコードを開発するときは、わかりやすさを優先することが重要です。

#### なぜそのようなコードになっているのか？

コードの根拠は、変数名、関数名、メソッド名、パッケージ名で十分に伝わることが多いです。そうでない場合は、コメントを追加することが重要です。特に、コードに読者が馴染みのないニュアンスが含まれている場合などは、「なぜ？」が重要です。

- 言語のニュアンス: たとえば、クロージャがループ変数を捕捉しているが、クロージャは何行も先にある
- ビジネスロジックのニュアンス:  たとえば、実際のユーザーとなりすましたユーザーを区別する必要のあるアクセス制御チェック

APIを正しく使用するために注意が必要な場合があるかもしれません。たとえば、パフォーマンス上の理由からコードの一部が入り組んでいて追跡が困難な場合や、複雑な数学演算のシーケンスで予想外の方法で型変換が行われる場合があります。このような場合、またそれ以外にも多くの場合、将来のメンテナがミスをしないように、また読者がリバースエンジニアリングをしなくてもコードを理解できるように、付随するコメントや ドキュメントでこれらの側面を説明することが重要です。

また、分かりやすくするために余計なコメントをつけると、かえってコードが散らかったり、すでに書いてあることを繰り返し書いたり、コードと矛盾したり、コメントを最新に保つためにメンテナンスの負担が増えたりして、コードの目的が分からなくなることがあるので注意が必要です。冗長なコメントを追加するのではなく、コードが自ら語るようにします（たとえば、シンボル名自体を自己記述型にする）。コメントは、コードが何をしているかではなく、なぜそれが行われるのかを説明する方がよい場合が多いです。

Googleのコードベースは、ほぼ均一で一貫しています。見慣れないパターンを使っているなど、目立つコードにはそれなりの理由があることがよくあります。この性質を維持することは、新しいコードを読むときにどこに注目すべきかを読者に明らかにするために重要です。

標準ライブラリには、この原則を実践している例がたくさんあります。そのうちのひとつが以下です。

- [sortパッケージ](https://cs.opensource.google/go/go/+/refs/tags/go1.19.2:src/sort/sort.go)におけるメンテナコメント
- [同じパッケージの中にある実行可能な良いサンプル](https://cs.opensource.google/go/go/+/refs/tags/go1.19.2:src/sort/example_search_test.go)は、ユーザー（[godocに表示される](https://pkg.go.dev/sort#pkg-examples)）とメンテナ（[テストの一部として実行される](https://google.github.io/styleguide/go/decisions#examples)）の両方に利益をもたらします。
- [strings.Cut](https://pkg.go.dev/strings#Cut)はたった4行のコードですが、[呼び出しの明確さと正確さ](https://github.com/golang/go/issues/46336)を向上させるものです。

### シンプルさ

あなたのGoコードは、それを使用する人、読む人、保守する人にとってシンプルであるべきです。

Go のコードは、動作や性能の面で目標を達成するために最もシンプルな方法で書かれるべきです。GoogleのGoのコードベースでは、シンプルなコードは次のようになります。

- 上から下まで読みやすい
- 何をやっているかわかっていることを前提にしない
- 直前のコードをすべて記憶していることを前提にしていない
- 不必要に抽象化されていない
- ありふれたものに注意を喚起するような名前でないこと
- 価値や判断の伝達を読者にとって明確にする
- 将来の逸脱を避けるため、コードが何をやっているかではなく、なぜやっているかを説明するコメントがある
-独立したドキュメントがある
- 有用なエラーと有用なテストの失敗がある
- 「賢い」コードと相反する場合がよくある

コードのシンプルさとAPIの使い方のシンプルさの間にはトレードオフが生じ得ます。たとえば、APIのエンドユーザーがより簡単にAPIを正しく呼び出せるように、コードをより複雑にすることに価値があるかもしれません。逆に、コードがシンプルで理解しやすいように、APIのエンドユーザーに少し余分な作業を任せることにも価値があるかもしれません。

コードが複雑さを必要とする場合、複雑さは意図的に追加されるべきです。これは通常、さらなるパフォーマンスが必要な場合や、特定のライブラリやサービスを利用する顧客が複数存在する場合に必要です。複雑なコードは正当化されるかもしれませんが、顧客や将来のメンテナが複雑さを理解し操作できるように、付随するドキュメントを用意すべきです。特に、そのコードを使うのに「シンプル」な方法と「複雑」な方法の両方がある場合は、正しい使い方を示すテストや例で補う必要があります。

この原則は、複雑なコードはGoで書けない、または書くべきではない、あるいはGoのコードは複雑であってはいけないということを意味するものではありません。私たちは、不必要な複雑さを避けるコードベースを目指しており、複雑さが現れた場合は、問題のコードを理解し維持するために注意が必要であることを示します。理想的には、その根拠を説明し、注意すべき点を明らかにするコメントを添えるべきでしょう。パフォーマンスのためにコードを最適化するとき、このようなことがよく起こります。たとえば、バッファを事前に割り当てておき、ゴルーチンのライフタイムを通じてそれを再利用するなど、より複雑なアプローチが必要になることがよくあります。メンテナがこれを見たら、そのコードがパフォーマンス的に重要であることを示す手がかりとなり、今後の変更の際に注意を払うべきでしょう。一方、不必要に複雑化すると、将来そのコードを読んだり変更したりする必要がある人にとって負担となります。

目的がシンプルであるはずのコードが非常に複雑であることが判明した場合、これは同じことを達成するためにもっとシンプルな方法がないか、実装を見直す合図になることが多いのです。

#### 最小限のメカニズム

同じアイデアを表現する方法がいくつかある場合、最も標準的なツールを使用するものを選びます。洗練されたシステムはしばしば存在しますが、理由なく採用するべきではありません。必要に応じてコードを複雑にするのは簡単ですが、既存の複雑さが不要であることが分かった後にそれを取り除くのは非常に困難です。

1. 使用するケースで十分な場合は、中核となる言語構造（チャネル、スライス、マップ、ループ、構造体など）を使用することを目指します。
2. ない場合は、標準ライブラリ内のツール（HTTPクライアントやテンプレートエンジンのような）を探します。
3. 最後に、新しい依存関係を導入したり独自のライブラリを作成したりする前に、Googleのコードベースに十分なコアライブラリがあるかどうかを検討します。

例として、デフォルト値を持つ変数にフラグをバインドし、それをテストでオーバーライドしなければならないプロダクションコードを考えてみましょう。プログラムのコマンドラインインタフェースをテストするつもりでなければ (たとえば`os/exec`を使って)、 `flag.Set`を使うよりも直接その値をオーバーライドするほうが簡単で望ましいでしょう。

同様に、コードの一部が集合の構成要素確認を必要とする場合、ブール値のマップ（例えば、map[string]bool）で十分なことが多いです。集合のような型や機能を提供するライブラリは、マップでは不可能な、あるいは過度に複雑な操作が必要な場合にのみ使用する必要があります。

### 簡潔さ

簡潔なGoのコードは、高い信号対雑音比を持っています。関連する詳細を見分けるのは簡単で、命名と構造によって読者はこれらの詳細を理解することができます。

その時々に最も顕著な詳細を浮上させるためには、多くのことが邪魔になります。

- 繰り返し使用されるコード
- 余計な構文
- [不透明な名前]()
- 不必要な抽象化
- ホワイトスペース

特に繰り返しの多いコードは、ほぼ同一の部分ごとの差異が不明瞭になり、読み手は類似のコード行を視覚的に比較して変更点を見つけなければなりません。[テーブル駆動テスト](https://github.com/golang/go/wiki/TableDrivenTests)は、各繰り返しの重要な詳細から共通のコードを簡潔に因数分解できる仕組みの良い例ですが、どの部分をテーブルに含めるかの選択は、テーブルの理解しやすさに影響を及ぼします。

複数のコード構成方法を検討する場合、どの方法が最も重要な詳細を明らかにできるかを検討する価値があります。

また、一般的なコードの構成やイディオムを理解し使用することも、高い信号対雑音比を維持するために重要です。たとえば、次のコードブロックは[エラー処理](https://go.dev/blog/errors-are-values)で非常によく使われるもので、読者はこのブロックの目的をすぐに理解することができます。

```go
// Good:
if err := doSomething(); err != nil {
    // ...
}
```

これとよく似たコードでも、微妙に違っていると読者はその変化に気づかないかもしれません。このような場合、エラーチェックのシグナルを意図的に「[ブースト]()」して、注意を喚起するコメントを追加するとよいでしょう。

```go
// Good:
if err := doSomething(); err == nil { // if NO error
    // ...
}
```

### 保守性

コードは、書かれたときよりも何倍も編集されます。読みやすいコードは、その仕組みを理解しようとする読者にとって意味があるだけでなく、それを変更する必要のあるプログラマーにとっても意味があるのです。わかりやすさは重要です。

保守しやすいコード:

- 将来のプログラマーが正しく修正することが容易であること
- APIが優雅に成長するような構造になっていること
- 前提条件を明確にし、コードの構造ではなく問題の構造に対応する抽象化を選択する
- 不必要な結合を避け、使用されない機能は含めない
- 約束された動作が維持され、重要なロジックが正しいことを確認するための包括的なテストスイートがあり、テストは失敗の場合に明確で実行可能な診断を提供する

インターフェースや型のような抽象化されたものを使用する場合、定義上、それらが使用されるコンテキストから情報を削除するため、それらが十分な利点を提供することを確認することが重要です。エディタやIDEは、具象型を使用する場合はメソッドの定義に直接接続して対応するドキュメントを表示できますが、そうでない場合はインターフェースの定義しか参照することができません。インターフェースは強力なツールですが、インターフェースを正しく使用するために、メンテナが基礎となる実装の詳細を理解する必要がある場合があり、インターフェースのドキュメント内または呼出し側で説明しなければならないため、コストが発生します。

また、メンテナンス性の高いコードは、見落としやすい場所に重要な詳細を隠さないようにします。たとえば、以下の各コード行では、1文字の有無がその行を理解する上で重要です。

```go
// Bad:
// := でなく = を使用するとこの行の意味を完全変え得る
if user, err = db.UserByID(userID); err != nil {
    // ...
}
```

```go
// Bad:
// この行の途中にある ! はとても見逃しやすい
leap := (year%4 == 0) && (!(year%100 == 0) || (year%400 == 0))
```

どちらも間違ってはいませんが、もっと明確に書くか、重要な動作に注意を促すコメントを添えるなどの工夫が必要でしょう。

```go
// Good:
u, err := db.UserByID(userID)
if err != nil {
    return fmt.Errorf("invalid origin user: %s", err)
}
user = u
```

```go
// Good:
// グレゴリオ暦の閏年は、year%4==0だけではありません。
// 参照 https://en.wikipedia.org/wiki/Leap_year#Algorithm
var (
    leap4   = year%4 == 0
    leap100 = year%100 == 0
    leap400 = year%400 == 0
)
leap := leap4 && (!leap100 || leap400)
```

同様に、重要なロジックやエッジケースを隠すようなヘルパー関数は、将来の変更で適切に考慮されなくなる可能性があります。

予測可能な名前は、メンテナンス可能なコードのもう一つの特徴です。パッケージのユーザーやコードのメンテナは、与えられたコンテキストで変数、メソッド、関数の名前を予測できる必要があります。同じ概念の関数パラメータとレシーバー名は、通常、同じ名前を共有する必要があります。これは、ドキュメントをわかりやすくし、最小限のオーバーヘッドでコードのリファクタリングを容易にするためです。

保守性の高いコードは、依存関係を最小限に抑えます（暗黙的および明示的な依存関係の両方）。より少ないパッケージへの依存は、動作に影響を与えるコードの行数を減らすことを意味します。内部動作や ドキュメント化されていない動作への依存を避けることで、将来それらの動作が変更されたときにコードがメンテナンスの負担となる可能性を低くします。

コードをどのように構成するか、あるいは書くかを考えるとき、そのコードが時間の経過とともにどのように進化するかを考える時間を取る価値があります。もし、あるアプローチの方が将来の変更をより簡単かつ安全に行えるのであれば、たとえ設計が多少複雑になったとしても、それは良いトレードオフであることが多いのです。

### 一貫性

一貫性のあるコードとは、より広いコードベース全体、チームやパッケージのコンテキスト、さらには1つのファイル内でも、同様のコードのように見え、感じ、動作するコードのことです。

一貫性を保つことは、上記の原則を覆すものではありませんが、均衡を破る必要がある場合は、一貫性を保つために均衡を破ることが有益であることがよくあります。

パッケージ内の一貫性は、多くの場合、最も即座に重要なレベルです。同じ問題がパッケージ全体で複数の方法でアプローチされていたり、同じコンセプトがファイル内で多くの名前を持っていたりすると、大きな違和感を覚えるかもしれません。しかし、このような場合でも、ドキュメント化されたスタイルの原則やグローバルな一貫性を上書きしてはいけません。
